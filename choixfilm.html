<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visionary</title>
    <!-- Chargement de Tailwind CSS via CDN pour le style moderne et responsive -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Configuration Tailwind pour un th√®me sombre cin√©matique -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-dark': '#0f172a', // Bleu nuit / Slate-900
                        'secondary-dark': '#1e293b', // Slate-800
                        'accent': '#3b82f6', // Bleu vif / Blue-500
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        /* Styles personnalis√©s pour les effets visuels (transition et scrollbar) */
        body {
            /* CORRECTION: Suppression des guillemets pour garantir le fond noir */
            background-color: #0f172a; 
            color: #f8fafc; /* Texte blanc/gris clair */
            min-height: 100vh;
        }
        /* Effet d'apparition progressif (chargement) */
        .fade-in {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.5s ease-out forwards;
        }
        @keyframes fadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
                /* √âvite le flash noir au chargement */
            }
        }
        /* Style pour les affiches dans le mode grille */
        .poster-card {
            transition: transform 0.3s ease, box-shadow 0.3s ease, opacity 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }
        /* Style au survol uniquement si le film est jouable */
        .poster-card.playable:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 10px 30px rgba(59, 130, 246, 0.4); /* Ombre accentu√©e au survol */
        }
        /* Style pour les films non-jouables */
        .poster-card.unplayable {
            opacity: 0.6;
            filter: grayscale(80%);
            cursor: default;
        }
        
        .poster-image {
            aspect-ratio: 2 / 3;
            object-fit: cover;
        }
        /* Style de la modale */
        .modal-container {
            transition: opacity 0.3s ease;
        }
        .modal-content {
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        /* Barre de d√©filement stylis√©e pour le design sombre */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #3b82f6; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #60a5fa; }

    </style>
</head>
<body class="font-sans">

    <!-- En-t√™te et barre de contr√¥le -->
    <header class="bg-secondary-dark shadow-lg sticky top-0 z-10 p-4 md:p-6">
        <div class="max-w-7xl mx-auto flex flex-col md:flex-row justify-between items-center space-y-4 md:space-y-0">
            <h1 class="text-3xl font-bold text-accent tracking-wider">Visionary</h1>

            <!-- Contr√¥les : Recherche, Mode d'affichage, Rechargement -->
            <div class="flex flex-wrap justify-center gap-3 w-full md:w-auto">

                <!-- Champ de Recherche -->
                <div class="relative w-full sm:w-64">
                    <input type="text" id="searchInput" placeholder="Rechercher par titre..." class="w-full p-2 pl-10 rounded-lg bg-primary-dark border border-secondary-dark focus:border-accent focus:ring-1 focus:ring-accent text-sm transition" oninput="filterMovies(this.value)">
                    <svg class="absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                </div>

                <!-- Bouton Bascule Vue -->
                <button id="toggleViewBtn" class="p-2 rounded-lg bg-accent hover:bg-blue-600 transition text-sm font-semibold flex items-center shadow-md" onclick="toggleViewMode()">
                    <svg id="viewIcon" class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"></path></svg>
                    <span>Mode Grille</span>
                </button>

                <!-- S√©lecteur Rechargement Automatique -->
                <select id="autoReloadSelect" class="p-2 rounded-lg bg-primary-dark border border-secondary-dark focus:border-accent focus:ring-1 focus:ring-accent text-sm transition" onchange="setupAutoReload()">
                    <option value="0">Rechargement d√©sactiv√©</option>
                    <option value="30000">Recharger toutes les 30s</option>
                    <option value="60000">Recharger toutes les 60s</option>
                    <option value="300000">Recharger toutes les 5m</option>
                </select>
            </div>
        </div>
    </header>

    <!-- Contenu Principal -->
    <main class="max-w-7xl mx-auto p-4 md:p-6">
        <!-- Zone d'affichage des messages (erreurs, chargement) -->
        <div id="messageArea" class="py-4">
            <!-- Message de chargement initial -->
            <div id="loadingMessage" class="flex items-center text-accent">
                <svg class="animate-spin -ml-1 mr-3 h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                Chargement des films depuis films.txt...
            </div>
        </div>

        <!-- Conteneur des films -->
        <div id="moviesContainer" class="min-h-[50vh]">
            <!-- Les films seront ins√©r√©s ici par le JavaScript -->
        </div>

    </main>

    <!-- Modale de Lecture (cach√©e par d√©faut) -->
    <div id="playerModal" class="fixed inset-0 bg-black bg-opacity-90 z-50 hidden modal-container p-4 overflow-y-auto" onclick="closeModal(event)">
        <div class="relative max-w-4xl mx-auto bg-secondary-dark rounded-xl shadow-2xl p-4 md:p-8 modal-content" onclick="event.stopPropagation()">
            <!-- Bouton Fermer -->
            <button class="absolute top-4 right-4 text-gray-300 hover:text-accent transition" onclick="closeModal()">
                <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>

            <h2 id="modalTitle" class="text-3xl font-bold text-white mb-4 pr-10">Titre du Film</h2>

            <!-- Lecteur StreamTape int√©gr√© -->
            <div class="aspect-video bg-primary-dark rounded-lg overflow-hidden mb-6">
                <!-- Correction: Ajout de referrerpolicy="no-referrer" pour √©viter les probl√®mes de lecture (CORS/Referrer) -->
                <iframe id="streamTapePlayer" class="w-full h-full" src=""
                        allow="autoplay; fullscreen; encrypted-media" 
                        frameborder="0" 
                        referrerpolicy="no-referrer" 
                        allowfullscreen></iframe>
            </div>

            <!-- Description du film dans la modale -->
            <p id="modalDescription" class="text-gray-300 mb-4"></p>

            <!-- Lien pour ouvrir dans un nouvel onglet (sera masqu√© si pas d'URL valide) -->
            <a id="modalExternalLink" href="#" target="_blank" class="inline-flex items-center text-accent hover:text-blue-400 transition font-semibold text-sm">
                Ouvrir le lecteur dans un nouvel onglet
                <svg class="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path></svg>
            </a>
        </div>
    </div>


    <script>
        // --- CONSTANTES ET VARIABLES GLOBALES ---
        const TMDB_API_KEY = 'cc8c196133c6efa48fd2edc1e20967a7'; // Cl√© TMDB
        const TMDB_BASE_URL = 'https://api.themoviedb.org/3/movie/';
        // URL de base pour les images TMDB
        const TMDB_IMAGE_BASE_URL = 'https://image.tmdb.org/t/p/'; 
        const TMDB_LANGUAGE = 'fr-FR';

        let moviesData = []; // Stocke tous les films charg√©s
        let currentViewMode = 'grid'; // 'grid' ou 'list'
        let reloadIntervalId = null; // ID de l'intervalle de rechargement

        // --- √âL√âMENTS DU DOM ---
        const moviesContainer = document.getElementById('moviesContainer');
        const messageArea = document.getElementById('messageArea');
        const searchInput = document.getElementById('searchInput');
        const toggleViewBtn = document.getElementById('toggleViewBtn');
        const viewIcon = document.getElementById('viewIcon');
        const playerModal = document.getElementById('playerModal');
        const streamTapePlayer = document.getElementById('streamTapePlayer');
        const modalTitle = document.getElementById('modalTitle');
        const modalDescription = document.getElementById('modalDescription');
        const modalExternalLink = document.getElementById('modalExternalLink');

        
        /**
         * S√©curise une cha√Æne pour qu'elle soit utilis√©e comme valeur d'attribut HTML.
         * Nettoie les caract√®res de contr√¥le invisibles.
         * @param {string} str - La cha√Æne √† nettoyer (l'URL StreamTape).
         * @returns {string} L'URL nettoy√©e.
         */
        function sanitizeUrl(str) {
            if (!str) return '';
            // Supprime les espaces blancs invisibles et les caract√®res de contr√¥le non n√©cessaires
            return str.replace(/[\u200B-\u200F\uFEFF\u00AD\t\n\r]/g, '').trim();
        }

        // --- LOGIQUE DE GESTION DES MESSAGES ET ERREURS ---

        /**
         * Affiche un message (erreur ou info) √† l'utilisateur.
         * @param {string} message - Le texte du message.
         * @param {string} type - Le type de message ('loading', 'error', 'success').
         */
        function displayMessage(message, type = 'info') {
            let bgColor, textColor, icon;
            messageArea.classList.remove('hidden');

            switch (type) {
                case 'loading':
                    bgColor = 'bg-secondary-dark';
                    textColor = 'text-accent';
                    icon = '<svg class="animate-spin -ml-1 mr-3 h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>';
                    break;
                case 'error':
                    bgColor = 'bg-red-900/50';
                    textColor = 'text-red-400';
                    icon = '<svg class="h-5 w-5 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>';
                    break;
                case 'success':
                    bgColor = 'bg-green-900/50';
                    textColor = 'text-green-400';
                    icon = '<svg class="h-5 w-5 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>';
                    break;
                default:
                    bgColor = 'bg-secondary-dark';
                    textColor = 'text-gray-300';
                    icon = '';
            }

            messageArea.innerHTML = `
                <div class="${bgColor} ${textColor} p-4 rounded-xl shadow-lg flex items-center mb-4 transition duration-500 fade-in">
                    ${icon}
                    <p>${message}</p>
                </div>
            `;
        }

        /**
         * Affiche un message temporaire et le masque apr√®s une dur√©e donn√©e.
         * @param {string} message - Le texte du message.
         * @param {string} type - Le type de message ('loading', 'error', 'success').
         * @param {number} duration - Dur√©e en ms avant de masquer.
         */
        function displayTempMessage(message, type, duration = 3000) {
            displayMessage(message, type);
            setTimeout(() => { 
                messageArea.innerHTML = ''; 
                messageArea.classList.add('hidden');
            }, duration);
        }

        // --- FONCTIONS DE CHARGEMENT DES DONN√âES ---

        /**
         * 1. Lit et parse le fichier films.txt.
         * @returns {Promise<Array<{tmdbId: string, streamTapeUrls: string[]}>>} Liste des films bruts.
         */
        async function loadMovieIds() {
            try {
                // Utilisation de 'no-cache' pour √©viter les probl√®mes de cache persistants
                const response = await fetch('films.txt', { cache: 'no-cache' }); 
                if (!response.ok) {
                    // Si films.txt n'existe pas, on affiche un message d'erreur
                    throw new Error(`Erreur HTTP: ${response.status}. V√©rifiez le nom du fichier.`);
                }
                const text = await response.text();
                
                const lines = text.split('\n');
                const rawMovies = [];

                lines.forEach(line => {
                    // Nettoyage strict: Supprime le BOM, les retours chariot, et les espaces de d√©but/fin.
                    const cleanLine = line.replace(/^\uFEFF/, '').trim().replace(/[\r\n]/g, ''); 
                    
                    // Ignore les lignes vides ou les commentaires (#)
                    if (cleanLine === '' || cleanLine.startsWith('#')) {
                        return;
                    }

                    // Utilisation du point-virgule (;) comme S√âPARATEUR
                    const parts = cleanLine.split(';').map(p => p.trim());
                    
                    if (parts.length >= 1 && parts[0] !== '') {
                        const tmdbId = parts[0];
                        // Applique la fonction de nettoyage pour garantir des URLs s√ªres
                        const streamTapeUrls = parts.slice(1).map(url => sanitizeUrl(url)).filter(url => url !== ''); 
                        
                        if (streamTapeUrls.length > 0) {
                            console.log(`D√©bogage Lecture: ID ${tmdbId} lu avec ${streamTapeUrls.length} URL(s)`);
                        } else {
                            console.warn(`D√©bogage Lecture: ID ${tmdbId} lu, mais aucune URL StreamTape trouv√©e.`);
                        }

                        rawMovies.push({ tmdbId, streamTapeUrls });
                    }
                });
                
                return rawMovies;

            } catch (error) {
                console.error("Erreur lors du chargement de films.txt:", error);
                displayMessage(`Impossible de charger **films.txt**. D√©tail: ${error.message}`, 'error');
                return [];
            }
        }

        /**
         * 2. R√©cup√®re les m√©tadonn√©es TMDB pour un film.
         * @param {string} tmdbId - ID TMDB du film.
         * @returns {Promise<Object|null>} Les donn√©es enrichies du film.
         */
        async function fetchTmdbData(tmdbId) {
            const url = `${TMDB_BASE_URL}${tmdbId}?api_key=${TMDB_API_KEY}&language=${TMDB_LANGUAGE}`;
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Film TMDB ID ${tmdbId} introuvable (Status: ${response.status})`);
                }
                const data = await response.json();

                // Formatage des donn√©es pertinentes
                return {
                    id: tmdbId,
                    title: data.title,
                    overview: data.overview || 'Description non disponible en fran√ßais.',
                    posterPath: data.poster_path,
                    releaseYear: data.release_date ? new Date(data.release_date).getFullYear() : 'N/A',
                    voteAverage: data.vote_average ? data.vote_average.toFixed(1) : 'N/A',
                };
            } catch (error) {
                console.warn(error.message);
                return null; // Retourne null si le film est introuvable
            }
        }

        /**
         * 3. Fonction principale pour charger tous les films.
         */
        async function loadAllMovies() {
            moviesContainer.innerHTML = ''; // Nettoyer l'affichage avant le chargement
            displayMessage("Chargement des films depuis films.txt...", 'loading');
            
            const rawMovies = await loadMovieIds();

            // S'il y a une erreur de chargement films.txt, on s'arr√™te ici
            if (rawMovies.length === 0 && messageArea.innerHTML.includes('Impossible de charger')) {
                return;
            }

            const tmdbPromises = rawMovies.map(async (rawMovie) => {
                const tmdbData = await fetchTmdbData(rawMovie.tmdbId);
                if (tmdbData) {
                    // Combine TMDB data with StreamTape URL
                    return { ...tmdbData, streamTapeUrls: rawMovie.streamTapeUrls };
                }
                return null;
            });

            // Attend que toutes les requ√™tes TMDB soient termin√©es
            const results = await Promise.all(tmdbPromises);
            moviesData = results.filter(movie => movie !== null);

            messageArea.innerHTML = ''; // Efface le message de chargement (le conteneur sera masqu√© si succ√®s)

            if (moviesData.length > 0) {
                // Tri par d√©faut par note (le meilleur d'abord)
                moviesData.sort((a, b) => b.voteAverage - a.voteAverage);
                renderMovies(moviesData);
                // Afficher un message de succ√®s temporaire
                displayTempMessage(`Chargement termin√© : ${moviesData.length} films affich√©s.`, 'success');
            } else if (rawMovies.length > 0) {
                // Afficher une erreur si le fichier √©tait pr√©sent mais les ID TMDB ont √©chou√©
                displayMessage(`Aucun film TMDB n'a pu √™tre charg√©. ${rawMovies.length} ID TMDB(s) non trouv√©s ou erreur API.`, 'error');
            } else {
                 // Si rawMovies est vide et pas d'erreur de fetch, c'est que films.txt est vide.
                 displayMessage("Le fichier films.txt a √©t√© trouv√©, mais ne contient aucune entr√©e de film valide.", 'error');
            }
        }


        // --- LOGIQUE D'AFFICHAGE DYNAMIQUE (GRID/LIST) ---

        /**
         * Rend un seul film en mode Grille.
         */
        function renderGridMovie(movie) {
            const posterUrl = movie.posterPath 
                ? `${TMDB_IMAGE_BASE_URL}w500${movie.posterPath}` 
                : 'https://placehold.co/500x750/1e293b/f8fafc?text=Affiche+Manquante';
            
            // Assure que les URLs sont des cha√Ænes (y compris la conversion de undefined en '')
            const url0 = movie.streamTapeUrls[0] || '';
            const url1 = movie.streamTapeUrls[1] || '';
            
            // LOG de d√©bogage pour l'injection HTML
            if (url0) {
                console.log(`D√©bogage Rendu GRILLE: Injection URL 0: "${url0}"`);
            }
            
            // Nouvelle logique : v√©rifie si au moins une URL est pr√©sente pour le rendre jouable
            const isPlayable = !!url0 || !!url1;
            const playableClass = isPlayable ? 'playable hover:ring-2 hover:ring-accent' : 'unplayable';
            const clickHandler = isPlayable ? 'openModal(this)' : 'displayTempMessage(\'URL StreamTape manquante. Film non-jouable.\', \'error\', 2000)';

            // REMARQUE: Les fonctions de rendu utilisent les variables nettoy√©es url0 et url1
            return `
                <div class="poster-card rounded-xl overflow-hidden bg-secondary-dark ${playableClass} fade-in" 
                     style="animation-delay: ${Math.random() * 0.2}s;"
                     onclick="${clickHandler}"
                     data-title="${movie.title}"
                     data-description="${movie.overview}"
                     data-url-0="${url0}"
                     data-url-1="${url1}">
                    
                    <!-- Indicateur visuel pour les non-jouables -->
                    ${!isPlayable ? '<div class="absolute top-0 left-0 bg-red-700/80 text-white text-xs font-bold p-1 rounded-br-lg z-10">URL MANQUANTE</div>' : ''}
                    
                    <!-- Image de l'affiche -->
                    <img src="${posterUrl}" alt="Affiche de ${movie.title}" class="poster-image w-full"
                        onerror="this.onerror=null;this.src='https://placehold.co/500x750/1e293b/f8fafc?text=Affiche+Manquante';">
                    
                    <div class="p-3">
                        <h3 class="text-white font-semibold truncate">${movie.title}</h3>
                        <p class="text-xs text-gray-400">(${movie.releaseYear}) - ${movie.voteAverage}/10</p>
                    </div>
                </div>
            `;
        }

        /**
         * Rend un seul film en mode Liste.
         */
        function renderListMovie(movie) {
            const posterUrl = movie.posterPath 
                ? `${TMDB_IMAGE_BASE_URL}w200${movie.posterPath}` 
                : 'https://placehold.co/100x150/1e293b/f8fafc?text=N/A';
            
            // Assure que les URLs sont des cha√Ænes (y compris la conversion de undefined en '')
            const url0 = movie.streamTapeUrls[0] || '';
            const url1 = movie.streamTapeUrls[1] || '';
            
            // Nouvelle logique : v√©rifie si au moins une URL est pr√©sente
            const isPlayable = !!url0 || !!url1;
            const playableClass = isPlayable ? 'hover:bg-slate-700' : 'unplayable opacity-60';
            const clickHandler = isPlayable ? 'openModal(this)' : 'displayTempMessage(\'URL StreamTape manquante. Film non-jouable.\', \'error\', 2000)';

            return `
                <div class="flex bg-secondary-dark rounded-xl shadow-lg mb-4 p-4 items-start transition fade-in ${playableClass}" 
                     style="animation-delay: ${Math.random() * 0.1}s;">
                    
                    <!-- Affiche miniature -->
                    <img src="${posterUrl}" alt="Affiche de ${movie.title}" class="w-16 h-24 object-cover rounded-md flex-shrink-0 mr-4"
                         onerror="this.onerror=null;this.src='https://placehold.co/100x150/1e293b/f8fafc?text=N/A';">
                    
                    <div class="flex-grow">
                        <h3 class="text-xl font-bold text-white mb-1">${movie.title} <span class="text-sm font-normal text-gray-400">(${movie.releaseYear})</span></h3>
                        <p class="text-sm text-gray-300 mb-2 line-clamp-2">${movie.overview}</p>
                        
                        <!-- Note et Bouton -->
                        <div class="flex items-center justify-between">
                            <p class="text-sm font-medium text-amber-400">‚≠ê ${movie.voteAverage}/10</p>
                            <button class="px-4 py-2 rounded-lg text-white font-semibold transition shadow-md text-sm
                                    ${isPlayable ? 'bg-accent hover:bg-blue-600' : 'bg-gray-500 cursor-not-allowed'}"
                                    onclick="${clickHandler}"
                                    data-title="${movie.title}"
                                    data-description="${movie.overview}"
                                    data-url-0="${url0}"
                                    data-url-1="${url1}"
                                    ${!isPlayable ? 'disabled' : ''}>
                                ${isPlayable ? 'Regarder' : 'Non disponible'}
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }


        /**
         * Affiche tous les films dans le conteneur principal.
         * @param {Array<Object>} movies - La liste des films filtr√©s.
         */
        function renderMovies(movies) {
            moviesContainer.innerHTML = '';
            
            if (movies.length === 0) {
                moviesContainer.innerHTML = `
                    <p class="text-center text-gray-400 text-lg mt-10">Aucun film ne correspond √† votre recherche.</p>
                `;
                return;
            }

            if (currentViewMode === 'grid') {
                moviesContainer.className = 'grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-6';
                movies.forEach(movie => {
                    moviesContainer.innerHTML += renderGridMovie(movie);
                });
            } else { // list
                moviesContainer.className = 'flex flex-col space-y-4';
                movies.forEach(movie => {
                    moviesContainer.innerHTML += renderListMovie(movie);
                });
            }
        }


        // --- LOGIQUE D'INTERFACE UTILISATEUR ET INTERACTION ---

        /**
         * Bascule entre le mode grille et le mode liste.
         */
        function toggleViewMode() {
            currentViewMode = currentViewMode === 'grid' ? 'list' : 'grid';
            
            // Mise √† jour du bouton
            const pathGrid = 'M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z';
            const pathList = 'M4 6h16M4 10h16M4 14h16M4 18h16';

            if (currentViewMode === 'grid') {
                viewIcon.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${pathGrid}"></path>`;
                toggleViewBtn.querySelector('span').textContent = 'Mode Grille';
            } else {
                viewIcon.innerHTML = `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${pathList}"></path>`;
                toggleViewBtn.querySelector('span').textContent = 'Mode Liste';
            }
            
            // R√©affichage des films dans le nouveau mode
            renderMovies(moviesData);
        }

        /**
         * Filtre les films en temps r√©el bas√©s sur la saisie de l'utilisateur.
         * @param {string} query - Le texte de recherche.
         */
        function filterMovies(query) {
            const lowerCaseQuery = query.toLowerCase().trim();
            const filteredMovies = moviesData.filter(movie => 
                movie.title.toLowerCase().includes(lowerCaseQuery)
            );
            renderMovies(filteredMovies);
        }

        /**
         * Ouvre la modale de lecture avec le film s√©lectionn√©.
         * @param {HTMLElement} element - L'√©l√©ment cliqu√© (carte ou bouton).
         */
        function openModal(element) {
            const title = element.getAttribute('data-title');
            const originalDescription = element.getAttribute('data-description');
            
            // CORRECTION CRITIQUE: Utilisation de getAttribute() √† la place de dataset.
            // Cette m√©thode est plus fiable pour r√©cup√©rer des cha√Ænes longues contenant des caract√®res sp√©ciaux.
            const streamTapeUrl0 = element.getAttribute('data-url-0') || ''; 
            const streamTapeUrl1 = element.getAttribute('data-url-1') || '';
            
            // LOG DE D√âBOGAGE
            console.log("--- D√âBOGAGE openModal (Apr√®s Clic - getAttribute) ---");
            console.log(`URL 0 re√ßue: "${streamTapeUrl0}"`);
            console.log(`URL 1 re√ßue: "${streamTapeUrl1}"`);
            // --------------------------

            // Nouvelle fonction pour transformer l'URL StreamTape en URL d'embed (iframe)
            const getEmbedUrl = (url) => {
                if (!url || typeof url !== 'string' || url === '') {
                    return null; 
                }
                
                // Utilise une RegEx pour capturer la partie https://domaine/e/CODE
                const match = url.match(/(https:\/\/[^/]+\/e\/[a-zA-Z0-9_-]+)/);
                if (match) {
                    let embedBase = match[1];
                    // S'assurer qu'il se termine par un slash pour l'iframe
                    if (!embedBase.endsWith('/')) {
                        embedBase += '/';
                    }
                    return embedBase;
                }
                
                console.log(`√âchec de l'extraction RegEx pour l'URL StreamTape: ${url}. V√©rifiez le format /e/CODE.`);
                return null;
            };
            
            let finalEmbedUrl = getEmbedUrl(streamTapeUrl0);

            // Tente d'utiliser la deuxi√®me URL si la premi√®re est vide ou probl√©matique
            if (!finalEmbedUrl && streamTapeUrl1) {
                console.log(`Tentative d'utiliser l'URL secondaire: ${streamTapeUrl1}`);
                finalEmbedUrl = getEmbedUrl(streamTapeUrl1);
            }

            modalTitle.textContent = title;
            
            let displayDescription = originalDescription;
            let showExternalLink = false;
            
            // Gestion de l'affichage en fonction de la validit√© de l'URL
            if (finalEmbedUrl) {
                console.log(`Chargement de l'iframe avec l'URL finale: ${finalEmbedUrl}`);
                
                // URL valide
                streamTapePlayer.src = finalEmbedUrl;
                modalExternalLink.href = finalEmbedUrl;
                showExternalLink = true;
            } else {
                // URL Invalide
                 streamTapePlayer.src = ''; // Vide l'iframe
                 
                 console.error(`üö® √âCHEC CRITIQUE: Impossible de g√©n√©rer l'URL d'embed pour le film "${title}".`);
                 console.log(`Veuillez v√©rifier les URLs dans films.txt. URLs re√ßues: [0] = "${streamTapeUrl0}", [1] = "${streamTapeUrl1}"`);


                 // Affichage d'un message d'erreur dans la modale
                 displayDescription = originalDescription + "\n\nüö® ATTENTION: Aucune URL de streaming valide (format StreamTape /e/) n'a pu √™tre trait√©e pour ce film. V√©rifiez le fichier films.txt.";
                 showExternalLink = false;
            }
            
            modalDescription.textContent = displayDescription;

            if (showExternalLink) {
                modalExternalLink.classList.remove('hidden');
            } else {
                modalExternalLink.classList.add('hidden');
            }


            playerModal.classList.remove('hidden');
        }

        /**
         * Ferme la modale de lecture.
         * Stoppe la lecture de l'iframe en retirant le 'src'.
         */
        function closeModal(event) {
            // Permet de fermer en cliquant sur l'arri√®re-plan
            if (event && event.target.id !== 'playerModal') return; 

            streamTapePlayer.src = ''; // Stoppe la lecture (vidange l'iframe)
            playerModal.classList.add('hidden');
        }


        // --- LOGIQUE DE RECHARGEMENT AUTOMATIQUE ---

        /**
         * Met en place ou annule le rechargement automatique de la liste de films.
         */
        function setupAutoReload() {
            // Annule tout intervalle existant
            if (reloadIntervalId) {
                clearInterval(reloadIntervalId);
                reloadIntervalId = null;
            }

            const intervalMs = parseInt(document.getElementById('autoReloadSelect').value, 10);

            if (intervalMs > 0) {
                // D√©marre un nouvel intervalle
                reloadIntervalId = setInterval(() => {
                    console.log(`Rechargement automatique d√©clench√© (${intervalMs / 1000}s)...`);
                    loadAllMovies();
                }, intervalMs);
                displayTempMessage(`Rechargement automatique activ√© : toutes les ${intervalMs / 1000} secondes.`, 'info');
            } else {
                 displayTempMessage('Rechargement automatique d√©sactiv√©.', 'info');
            }
        }

        // --- INITIALISATION ---

        // Lance le chargement initial au d√©marrage de la page
        document.addEventListener('DOMContentLoaded', loadAllMovies);
    </script>
</body>
</html>
